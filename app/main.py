# ===================== PREVIDAS POSTGRESQL - C√ìDIGO COMPLETO =====================

from fastapi import FastAPI, HTTPException, BackgroundTasks, Request, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse
from pydantic import BaseModel
from fastapi.responses import RedirectResponse
from typing import Optional, Dict, List
import requests
import json
import asyncio
from datetime import datetime, timedelta
import pandas as pd
from enum import Enum
import re

# IMPORTS PARA .ENV 
import os
from dotenv import load_dotenv

# ============ IMPORTS POSTGRESQL ============
import asyncpg
from asyncpg import Pool
from contextlib import asynccontextmanager

app = FastAPI(title="Previdas Automation Engine PostgreSQL", version="2.0.0")

# CORS para permitir requisi√ß√µes do frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configurar arquivos est√°ticos e templates
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# ==================== CONFIGURA√á√ïES POSTGRESQL ====================
load_dotenv()

# Configura√ß√µes do banco
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://previdas:password123@localhost:5432/previdas")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Configurar cliente OpenAI
if OPENAI_API_KEY and OPENAI_API_KEY.startswith("sk-"):
    try:
        from openai import AsyncOpenAI
        openai_client = AsyncOpenAI(api_key=OPENAI_API_KEY)
        print(f"‚úÖ OpenAI configurada com chave: {OPENAI_API_KEY[:15]}...")
    except ImportError:
        openai_client = None
        print("‚ö†Ô∏è OpenAI n√£o instalada - usando fallback")
else:
    openai_client = None
    print("‚ö†Ô∏è OpenAI n√£o configurada - usando fallback")

# URLs dos sistemas
CRM_API_URL = "https://api.seu-crm.com"
WHATSAPP_API_URL = "https://api.whatsapp.business"
EMAIL_API_URL = "https://api.activecampaign.com"

# ============ POOL DE CONEX√ïES POSTGRESQL ============
db_pool: Optional[Pool] = None

async def get_db_pool() -> Pool:
    """Retorna o pool de conex√µes PostgreSQL"""
    global db_pool
    if db_pool is None:
        db_pool = await asyncpg.create_pool(
            DATABASE_URL,
            min_size=5,
            max_size=20,
            command_timeout=60
        )
        print(f"‚úÖ Pool PostgreSQL criado com sucesso!")
        print(f"   Conex√µes: 5-20 simult√¢neas")
        print(f"   Servidor: {DATABASE_URL.split('@')[1] if '@' in DATABASE_URL else 'localhost'}")
    return db_pool
async def close_db_pool():
    """Fecha o pool de conex√µes"""
    global db_pool
    if db_pool:
        await db_pool.close()
        print("‚úÖ Pool PostgreSQL fechado")

# ==================== FUN√á√ÉO CR√çTICA: NORMALIZA√á√ÉO DE TELEFONES ====================
def normalize_phone(phone: str) -> str:
    """
    Normaliza telefones para formato √∫nico - SOLU√á√ÉO PARA DUPLICA√á√ÉO
    
    Exemplos:
    - "+31 619 255 082" ‚Üí "619255082"
    - "(31) 61925-5082" ‚Üí "619255082"  
    - "31619255082" ‚Üí "619255082"
    """
    if not phone:
        return ""
    
    # Remove TODOS os caracteres n√£o num√©ricos
    clean = re.sub(r'[^\d]', '', str(phone))
    
    # Remove c√≥digo do pa√≠s Holanda (31) se presente
    if clean.startswith('31') and len(clean) > 10:
        clean = clean[2:]
    
    # Remove zeros √† esquerda se existirem
    clean = clean.lstrip('0')
    
    print(f"üìû Telefone normalizado: '{phone}' ‚Üí '{clean}'")
    return clean

# ==================== MODELOS PYDANTIC ====================
class LeadStatus(str, Enum):
    HOT = "hot"
    WARM = "warm"
    COLD = "cold"
    QUALIFIED = "qualified"
    CUSTOMER = "customer"

class Lead(BaseModel):
    phone: str
    name: Optional[str] = None
    message: str
    source: str
    status: LeadStatus = LeadStatus.COLD
    score: int = 0
    created_at: Optional[datetime] = None

class ChatMessage(BaseModel):
    phone: str
    message: str
    is_bot: bool = False
    timestamp: Optional[datetime] = None

class AutomationTrigger(BaseModel):
    trigger_type: str  # "new_lead", "message_received", "status_changed"
    data: Dict
    conditions: Optional[Dict] = None

# ============ BANCO DE DADOS POSTGRESQL ============
async def init_db():
    """Inicializa banco PostgreSQL com tabelas otimizadas para produ√ß√£o"""
    pool = await get_db_pool()
    
    async with pool.acquire() as conn:
        # ‚ùå LINHA REMOVIDA: await conn.execute("CREATE EXTENSION IF NOT EXISTS pg_stat_statements")
        
        # Tabela de leads com constraints e √≠ndices otimizados
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS leads (
                id SERIAL PRIMARY KEY,
                phone VARCHAR(20) UNIQUE NOT NULL,
                name VARCHAR(255),
                status VARCHAR(20) DEFAULT 'new' CHECK (status IN ('new', 'cold', 'warm', 'hot', 'qualified', 'customer')),
                score INTEGER DEFAULT 0 CHECK (score >= 0 AND score <= 100),
                source VARCHAR(50) DEFAULT 'whatsapp',
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Trigger para atualizar updated_at automaticamente
        await conn.execute('''
            CREATE OR REPLACE FUNCTION update_updated_at_column()
            RETURNS TRIGGER AS $$
            BEGIN
                NEW.updated_at = CURRENT_TIMESTAMP;
                RETURN NEW;
            END;
            $$ language 'plpgsql'
        ''')
        
        await conn.execute('''
            DROP TRIGGER IF EXISTS update_leads_updated_at ON leads;
            CREATE TRIGGER update_leads_updated_at 
                BEFORE UPDATE ON leads 
                FOR EACH ROW 
                EXECUTE FUNCTION update_updated_at_column()
        ''')
        
        # √çndices para performance m√°xima
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_leads_phone ON leads(phone)')
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status)')
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_leads_score ON leads(score)')
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_leads_updated_at ON leads(updated_at DESC)')
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_leads_score_status ON leads(score, status)')
        
        # Tabela de conversas
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS conversations (
                id SERIAL PRIMARY KEY,
                phone VARCHAR(20) NOT NULL,
                message TEXT NOT NULL,
                is_bot BOOLEAN DEFAULT FALSE,
                timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT fk_conversations_phone 
                    FOREIGN KEY (phone) REFERENCES leads(phone) 
                    ON DELETE CASCADE ON UPDATE CASCADE
            )
        ''')
        
        # √çndices para conversations
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_conversations_phone ON conversations(phone)')
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_conversations_timestamp ON conversations(timestamp DESC)')
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_conversations_phone_timestamp ON conversations(phone, timestamp DESC)')
        
        # Tabela de logs de automa√ß√£o
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS automation_logs (
                id SERIAL PRIMARY KEY,
                trigger_type VARCHAR(50) NOT NULL,
                phone VARCHAR(20) NOT NULL,
                action_taken VARCHAR(255),
                result VARCHAR(255),
                timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                metadata JSONB
            )
        ''')
        
        # √çndices para automation_logs
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_automation_logs_phone ON automation_logs(phone)')
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_automation_logs_timestamp ON automation_logs(timestamp DESC)')
        await conn.execute('CREATE INDEX IF NOT EXISTS idx_automation_logs_trigger_type ON automation_logs(trigger_type)')
        
        print("‚úÖ Tabelas PostgreSQL criadas com sucesso!")
        print("‚úÖ √çndices otimizados aplicados!")
        print("‚úÖ Triggers autom√°ticos configurados!")

# ==================== IA SERVICE OTIMIZADA ====================
class AIService:
    @staticmethod
    async def analyze_message(message: str, context: Dict = None) -> Dict:
        """An√°lise CORRIGIDA com prompts espec√≠ficos para Previdas"""
        
        # PROMPT COMPLETAMENTE REFORMULADO
        prompt = f"""Voc√™ √© um especialista em qualifica√ß√£o de leads para PREVIDAS (laudos m√©dicos para advogados).

REGRAS ESPEC√çFICAS PARA SCORING:

üè• PRODUTOS ESPEC√çFICOS (+30 pontos cada):
- "BPC" = Benef√≠cio de Presta√ß√£o Continuada
- "laudo" ou "per√≠cia" = produto direto
- "previdenci√°rio" / "trabalhista" = especialidades

üë®‚Äç‚öñÔ∏è IDENTIFICA√á√ÉO PROFISSIONAL:
- "advogado" = +40 pontos
- "escrit√≥rio" / "casos" / "clientes" = +30 pontos
- "doutor" / "especialista" = +25 pontos

‚ö° URG√äNCIA:
- "urgente" + contexto (audi√™ncia/prazo) = +25 pontos
- "preciso" / "necessito" = +15 pontos
- "hoje" / "amanh√£" = +20 pontos

EXEMPLOS CORRETOS DE SCORING:
- "preciso do laudo BPC" = 75 pontos (produto espec√≠fico + urg√™ncia)
- "sou advogado previdenci√°rio" = 85 pontos (profiss√£o + especialidade)
- "trabalham com que?" = 25 pontos (pergunta vaga)
- "oi" = 10 pontos (irrelevante)

RESPONDA APENAS JSON:
{{"intent": "valor", "urgency": "valor", "score": n√∫mero, "next_action": "valor", "sentiment": "valor"}}

VALORES PERMITIDOS:
- intent: "lawyer", "urgent_case", "product_inquiry", "price_inquiry", "casual", "unclear"
- urgency: "high", "medium", "low"
- score: 0-100
- next_action: "transfer_sales", "nurture", "collect_info", "qualify_more"
- sentiment: "positive", "neutral", "negative"

Mensagem: "{message}"

JSON:"""
        
        try:
            if openai_client:
                print(f"ü§ñ Analisando: {message[:50]}...")
                
                response = await openai_client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.1,
                    max_tokens=150,
                    response_format={"type": "json_object"}
                )
                
                result = json.loads(response.choices[0].message.content)
                print(f"‚úÖ OpenAI CORRIGIDA: {result}")
                return result
            else:
                raise Exception("OpenAI n√£o configurada")
                
        except Exception as e:
            print(f"‚ùå Erro IA: {e}")
            
            # FALLBACK CORRIGIDO COM L√ìGICA MELHORADA
            message_lower = message.lower()
            score = 20  # Score base mais alto
            
            # PRODUTOS ESPEC√çFICOS (prioridade m√°xima)
            if "bpc" in message_lower:
                score += 30  # BPC √© produto espec√≠fico
            if "laudo" in message_lower or "per√≠cia" in message_lower:
                score += 30  # Produto direto
            if "previdenci√°rio" in message_lower or "trabalhista" in message_lower:
                score += 25  # Especialidade espec√≠fica
            
            # IDENTIFICA√á√ÉO PROFISSIONAL
            if "advogado" in message_lower:
                score += 40  # Profiss√£o target
                if any(x in message_lower for x in ["especialista", "especializado"]):
                    score += 20  # Advogado especialista
            if any(x in message_lower for x in ["escrit√≥rio", "casos", "clientes"]):
                score += 25  # Contexto profissional
            
            # URG√äNCIA E NECESSIDADE
            if "preciso" in message_lower or "necessito" in message_lower:
                score += 15  # Demonstra necessidade
            if "urgente" in message_lower:
                score += 20  # Urg√™ncia
            if any(x in message_lower for x in ["hoje", "amanh√£", "audi√™ncia"]):
                score += 15  # Urg√™ncia contextual
            
            # PENALIZA√á√ïES REDUZIDAS
            if len(message_lower) < 8:
                score -= 5  # Penaliza√ß√£o menor para mensagens curtas
            
            if message_lower in ["oi", "ol√°", "hello", "hey", "e ai"]:
                score = 15  # Cumprimento b√°sico
            
            # Determinar inten√ß√£o baseada no score E conte√∫do
            if "advogado" in message_lower or score >= 70:
                intent = "lawyer"
            elif any(x in message_lower for x in ["laudo", "bpc", "per√≠cia"]):
                intent = "product_inquiry"
            elif any(x in message_lower for x in ["pre√ßo", "valor", "custo"]):
                intent = "price_inquiry"
            elif score >= 40:
                intent = "unclear"
            else:
                intent = "casual"
            
            result = {
                "intent": intent,
                "urgency": "high" if any(x in message_lower for x in ["urgente", "hoje", "amanh√£"]) else "medium" if score >= 50 else "low",
                "score": max(10, min(100, score)),  # M√≠nimo de 10 pontos
                "next_action": "transfer_sales" if score >= 75 else "nurture" if score >= 50 else "qualify_more",
                "sentiment": "positive" if score >= 60 else "neutral"
            }
            
            print(f"üîÑ Fallback CORRIGIDO: {result}")
            return result

    @staticmethod
    async def generate_response(message: str, lead_data: Dict, conversation_history: List) -> str:
        """Gera resposta ESPEC√çFICA para leads qualificados COM CONTEXTO"""
        
        message_lower = message.lower()
        score = lead_data.get('score', 0)
        status = lead_data.get('status', 'new')
        
        # VERIFICAR SE √â LEAD J√Å CONHECIDO COM SCORE ALTO
        is_known_lead = score >= 75 or status == "qualified"
        
        if is_known_lead:
            # RESPOSTAS CONTEXTUAIS PARA LEADS CONHECIDOS
            if "seguro" in message_lower:
                return "Ol√°! Somos especializados em laudos m√©dicos, n√£o seguros. Mas posso ajudar com laudos para seus processos previdenci√°rios. Precisa de algum laudo m√©dico?"
            elif any(x in message_lower for x in ["banco", "empr√©stimo", "financiamento"]):
                return "Ol√°! Nossa especialidade s√£o laudos m√©dicos para processos jur√≠dicos. Como posso ajudar com laudos para seus casos?"
            elif any(x in message_lower for x in ["curso", "treinamento", "capacita√ß√£o"]):
                return "Ol√°! Somos especialistas em laudos m√©dicos, n√£o cursos. Mas posso ajudar com laudos para seus processos. Tem algum caso pendente?"
        
        # Respostas espec√≠ficas para produtos mencionados
        if "bpc" in message_lower:
            if "urgente" in message_lower:
                return "Especialistas em BPC urgente! Emitimos laudos em 6h. Qual o prazo da audi√™ncia?"
            else:
                return "Perfeito! Somos especialistas em laudos BPC. Qual o CID do seu cliente?"
        
        elif "laudo" in message_lower:
            if "previdenci√°rio" in message_lower or "trabalhista" in message_lower:
                return "Especialistas nessa √°rea! Quantos laudos voc√™ precisa por m√™s?"
            else:
                return "Fazemos laudos m√©dicos especializados. Qual √°rea: previdenci√°rio, trabalhista ou civil?"
        
        elif "advogado" in message_lower:
            return "Perfeito! Ajudamos advogados com laudos m√©dicos h√° 10 anos. Qual sua especialidade?"
        
        else:
            # Resposta padr√£o para leads qualificados
            return "Vou conectar voc√™ com nosso especialista imediatamente. Qual o melhor hor√°rio para contato?"

    @staticmethod
    async def generate_nurture_response(message: str, lead_data: Dict, conversation_history: List) -> str:
        """Gera resposta de nutri√ß√£o MELHORADA COM CONTEXTO"""
        
        message_lower = message.lower()
        score = lead_data.get('score', 0)
        
        # Se lead tem score alto mas n√£o foi qualificado, ser mais direto
        if score >= 70:
            if "seguro" in message_lower:
                return "Entendi! N√£o trabalhamos com seguros, mas somos especialistas em laudos m√©dicos para advogados. Voc√™ atua na √°rea jur√≠dica?"
            elif "bpc" in message_lower or "previdenci√°rio" in message_lower:
                return "Somos especialistas em BPC! Nossos laudos t√™m 95% de aprova√ß√£o. Conectando com nosso especialista..."
            else:
                return "Entendo! Somos a Previdas, especialistas em laudos m√©dicos para advogados. Vou conectar voc√™ com nossa equipe especializada."
        
        # Respostas normais de nutri√ß√£o
        if "bpc" in message_lower or "previdenci√°rio" in message_lower:
            return "Somos especialistas em BPC! Nossos laudos t√™m 95% de aprova√ß√£o. Voc√™ √© advogado?"
        elif "laudo" in message_lower:
            return "Fazemos laudos m√©dicos para processos jur√≠dicos. Qual sua √°rea de atua√ß√£o?"
        elif "trabalham" in message_lower and "que" in message_lower:
            return "Laudos m√©dicos especializados para advogados. Voc√™ atua com previdenci√°rio ou trabalhista?"
        elif "pre√ßo" in message_lower or "valor" in message_lower:
            return "Nossos valores s√£o competitivos. Voc√™ trabalha com quantos casos por m√™s?"
        else:
            return "Entendi. Somos especialistas em laudos m√©dicos para advogados. Qual sua √°rea?"
    
    @staticmethod
    async def generate_qualification_response(message: str, lead_data: Dict, conversation_history: List) -> str:
        """Gera resposta de qualifica√ß√£o APRIMORADA COM CONTEXTO"""
        
        message_lower = message.lower()
        score = lead_data.get('score', 0)
        
        # Se √© lead com algum score mas mensagem fora do contexto
        if score >= 50:
            if "seguro" in message_lower:
                return "Ol√°! Nossa especialidade s√£o laudos m√©dicos para advogados, n√£o seguros. Voc√™ trabalha com direito?"
            elif any(x in message_lower for x in ["banco", "empr√©stimo", "investimento"]):
                return "Ol√°! Somos especializados em laudos m√©dicos para processos jur√≠dicos. Voc√™ √© advogado?"
        
        # Respostas normais de qualifica√ß√£o
        if "trabalham" in message_lower and "que" in message_lower:
            return "Fazemos laudos m√©dicos para processos jur√≠dicos. Voc√™ √© advogado?"
        elif len(message_lower) < 10:
            return "Ol√°! Somos especialistas em laudos m√©dicos para advogados. Qual sua profiss√£o?"
        else:
            return "Entendido. Somos a Previdas, laudos m√©dicos para advogados. Voc√™ atua na √°rea jur√≠dica?"

# ============ INTEGRA√á√ïES POSTGRESQL ============
class IntegrationService:
    @staticmethod
    async def send_to_crm(lead_data: Dict) -> bool:
        """Envia/atualiza lead no PostgreSQL com upsert otimizado"""
        try:
            normalized_phone = normalize_phone(lead_data["phone"])
            pool = await get_db_pool()
            
            async with pool.acquire() as conn:
                # Upsert otimizado com ON CONFLICT
                await conn.execute('''
                    INSERT INTO leads (phone, name, status, score, source, updated_at)
                    VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP)
                    ON CONFLICT (phone) 
                    DO UPDATE SET 
                        name = COALESCE(EXCLUDED.name, leads.name),
                        status = EXCLUDED.status,
                        score = EXCLUDED.score,
                        source = COALESCE(EXCLUDED.source, leads.source),
                        updated_at = CURRENT_TIMESTAMP
                ''', normalized_phone, lead_data.get("name"), lead_data["status"], 
                     lead_data["score"], lead_data.get("source", "whatsapp"))
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao enviar para CRM PostgreSQL: {e}")
            return False

    @staticmethod
    async def send_whatsapp(phone: str, message: str) -> bool:
        """Envia mensagem via WhatsApp Business API"""
        try:
            print(f"üì± WhatsApp para {phone}: {message}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao enviar WhatsApp: {e}")
            return False

    @staticmethod
    async def notify_sales_team(lead_data: Dict) -> bool:
        """Notifica equipe de vendas sobre lead quente"""
        try:
            message = f"""
üî• LEAD QUENTE PREVIDAS!
Nome: {lead_data.get('name', 'N/A')}
Phone: {lead_data['phone']}
Score: {lead_data['score']}/100
Status: Lead qualificado para laudos m√©dicos
A√ß√£o: Contatar IMEDIATAMENTE!
"""
            
            print(f"üö® Notifica√ß√£o vendas: {message}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao notificar vendas: {e}")
            return False

# ============ ENGINE DE AUTOMA√á√ÉO POSTGRESQL ============
class AutomationEngine:
    @staticmethod
    async def process_automation(trigger: AutomationTrigger):
        """Processa automa√ß√£o baseada no trigger"""
        
        if trigger.trigger_type == "new_lead":
            await AutomationEngine._handle_new_lead(trigger.data)
        
        elif trigger.trigger_type == "message_received":
            await AutomationEngine._handle_message(trigger.data)
        
        elif trigger.trigger_type == "status_changed":
            await AutomationEngine._handle_status_change(trigger.data)

    @staticmethod
    async def _handle_new_lead(data: Dict):
        """Automa√ß√£o para novo lead"""
        
        # 1. Normalizar telefone
        normalized_phone = normalize_phone(data["phone"])
        data["phone"] = normalized_phone
        
        # 2. Salva no CRM
        await IntegrationService.send_to_crm(data)
        
        # 3. Envia mensagem de boas-vindas
        welcome_msg = "Ol√°! Sou da Previdas, especialistas em laudos m√©dicos para advogados. Como posso ajudar?"
        await IntegrationService.send_whatsapp(data["phone"], welcome_msg)
        
        # 4. Log da automa√ß√£o
        await AutomationEngine._log_automation("new_lead", normalized_phone, "welcome_sent", "success")

    @staticmethod
    async def _handle_message(data: Dict):
        """AUTOMA√á√ÉO POSTGRESQL - L√≥gica de scoring otimizada COM CONTEXTO HIST√ìRICO CORRIGIDO"""
        
        # 0. NORMALIZAR TELEFONE (CR√çTICO)
        normalized_phone = normalize_phone(data["phone"])
        data["phone"] = normalized_phone
        
        # 1. Busca dados do lead (PostgreSQL otimizado)
        lead_data = await AutomationEngine._get_lead_data(normalized_phone)
        
        # 2. Analisa mensagem com IA CORRIGIDA
        analysis = await AIService.analyze_message(data["message"], lead_data)
        
        # 3. L√ìGICA DE SCORING COMPLETAMENTE CORRIGIDA
        current_score = lead_data.get("score", 0)
        current_status = lead_data.get("status", "new")
        ai_score = analysis["score"]
        message_lower = data["message"].lower()
        
        print(f"üîç DEBUG SCORING PostgreSQL:")
        print(f"  üìä Current Score: {current_score}")
        print(f"  üìã Current Status: {current_status}")
        print(f"  ü§ñ AI Score: {ai_score}")
        print(f"  üí¨ Message: '{data['message']}'")
        
        # PALAVRAS-CHAVE QUE INDICAM QUALIDADE
        product_keywords = ["bpc", "laudo", "per√≠cia", "previdenci√°rio", "trabalhista"]
        professional_keywords = ["advogado", "escrit√≥rio", "casos", "clientes"]
        urgency_keywords = ["urgente", "preciso", "necessito", "hoje", "amanh√£"]
        
        has_product_keywords = any(kw in message_lower for kw in product_keywords)
        has_professional_keywords = any(kw in message_lower for kw in professional_keywords)
        has_urgency_keywords = any(kw in message_lower for kw in urgency_keywords)
        
        # NOVA L√ìGICA DE SCORING (SEM DECAY DESNECESS√ÅRIO)
        if has_product_keywords or has_professional_keywords:
            # Mensagem sobre produtos ou identifica√ß√£o profissional = SEMPRE melhora score
            new_score = max(current_score, ai_score, 70)  # M√≠nimo 70 para produtos espec√≠ficos
            print(f"  ‚úÖ PRODUTO/PROFISSIONAL mencionado - Score garantido: {new_score}")
            
        elif ai_score >= 60:
            # Mensagem boa - mant√©m o melhor score
            new_score = max(current_score, ai_score)
            print(f"  ‚úÖ Mensagem BOA - Score: {new_score}")
            
        elif ai_score >= 40:
            # Mensagem neutra - score ponderado suave
            new_score = int((current_score * 0.85) + (ai_score * 0.15))
            print(f"  üü° Mensagem NEUTRA - Score ponderado: {new_score}")
            
        else:
            # Mensagem ruim - decay muito limitado
            if len(data["message"]) < 6 and not any(kw in message_lower for kw in ["oi", "ol√°", "hey"]):
                # Apenas mensagens muito ruins e curtas recebem decay
                new_score = max(current_score - 10, current_score * 0.9, 20)  # Redu√ß√£o m√°xima de 10 pontos
                print(f"  ‚ùå Mensagem RUIM - Decay limitado: {new_score}")
            else:
                # Cumprimentos normais n√£o recebem penaliza√ß√£o
                new_score = current_score
                print(f"  üòê Cumprimento/Mensagem normal - Score mantido: {new_score}")
        
        # Garantir limites
        new_score = max(10, min(100, int(new_score)))
        lead_data["score"] = new_score
        
        print(f"üìä RESULTADO FINAL: {current_score} ‚Üí {new_score} (IA: {ai_score})")
        
        # 4. L√ìGICA DE QUALIFICA√á√ÉO COM CONTEXTO HIST√ìRICO (CORRE√á√ÉO FINAL)
        has_quality_keywords = has_product_keywords or has_professional_keywords or has_urgency_keywords
        
        print(f"üîç Keywords: Produto={has_product_keywords}, Profissional={has_professional_keywords}, Urg√™ncia={has_urgency_keywords}")
        
       # VERIFICAR CONTEXTO HIST√ìRICO PRIMEIRO (PRIORIDADE M√ÅXIMA)
        already_qualified = current_status == "qualified"
        has_high_historical_score = new_score >= 80
        
        # L√ìGICA CORRIGIDA: CONTEXTO HIST√ìRICO TEM PRIORIDADE ABSOLUTA
        if already_qualified and ai_score >= 20:
            # Lead j√° qualificado + mensagem n√£o muito negativa = MANTER QUALIFICA√á√ÉO
            lead_data["status"] = "qualified"
            final_status = "qualified"
            print(f"üîÑ Lead qualificado MANTIDO (contexto hist√≥rico: {current_status})")
            
        elif has_high_historical_score and ai_score >= 30:
            # Lead com score alto hist√≥rico + mensagem n√£o muito negativa = RE-QUALIFICAR
            lead_data["status"] = "qualified"
            final_status = "qualified"
            print(f"üîÑ Lead RE-QUALIFICADO por score hist√≥rico alto ({new_score})")
            
        else:
            # APENAS AQUI aplicar l√≥gica normal para leads novos ou com score baixo
            is_hot_lead = (
                new_score >= 75 and
                (has_quality_keywords or analysis["intent"] in ["lawyer", "product_inquiry"]) and
                len(data["message"]) > 5
            )
            
            if is_hot_lead:
                lead_data["status"] = "qualified"
                final_status = "qualified"
                print(f"üî• Lead NOVA qualifica√ß√£o! Score: {new_score}")
            elif new_score >= 50 and has_quality_keywords:
                lead_data["status"] = "warm"
                final_status = "warm"
                print(f"üå°Ô∏è Lead morno - nutri√ß√£o")
            else:
                lead_data["status"] = "cold"
                final_status = "cold"
                print(f"‚ùÑÔ∏è Lead frio - qualifica√ß√£o")
        
        # ‚úÖ CORRE√á√ÉO ADICIONAL: GARANTIR QUE CONTEXTO HIST√ìRICO SEJA SEMPRE RESPEITADO
        if current_status == "qualified" and new_score >= 75:
            if final_status != "qualified":
                lead_data["status"] = "qualified"
                final_status = "qualified"
                print(f"üîÑ CORRE√á√ÉO FINAL: Contexto hist√≥rico recuperado! Status: qualified")
        
        # Debug do status final
        print(f"üìã STATUS FINAL CONFIRMADO: {final_status}")
        
        # 5. Gerar resposta baseada no STATUS FINAL (n√£o no is_hot_lead)
        conversation_history = await AutomationEngine._get_conversation_history(normalized_phone)
        
        if final_status == "qualified":
            # Lead qualificado - resposta de vendas com contexto
            if current_status != "qualified":
                # Novo lead qualificado - notificar vendas
                await IntegrationService.notify_sales_team(lead_data)
                print(f"üö® Notifica√ß√£o de vendas enviada para novo lead qualificado")
            else:
                print(f"üîÑ Lead j√° qualificado - sem nova notifica√ß√£o")
            
            bot_response = await AIService.generate_response(data["message"], lead_data, conversation_history)
            print(f"üí¨ Resposta de VENDAS gerada (lead qualificado)")
            
        elif final_status == "warm":
            # Lead morno - nutri√ß√£o
            bot_response = await AIService.generate_nurture_response(data["message"], lead_data, conversation_history)
            print(f"üí¨ Resposta de NUTRI√á√ÉO gerada (lead morno)")
            
        else:
            # Lead frio - qualifica√ß√£o
            bot_response = await AIService.generate_qualification_response(data["message"], lead_data, conversation_history)
            print(f"üí¨ Resposta de QUALIFICA√á√ÉO gerada (lead frio)")
        
        # 6. Enviar resposta e salvar (PostgreSQL otimizado)
        await IntegrationService.send_whatsapp(normalized_phone, bot_response)
        
        await AutomationEngine._save_conversation(normalized_phone, data["message"], False)
        await AutomationEngine._save_conversation(normalized_phone, bot_response, True)
        await IntegrationService.send_to_crm(lead_data)
        
        print(f"‚úÖ Processamento PostgreSQL CORRIGIDO conclu√≠do - Score final: {new_score}, Status: {final_status}")
        print("="*60)
    
    @staticmethod
    async def _handle_status_change(data: Dict):
        """Automa√ß√£o para mudan√ßa de status"""
        print(f"Status changed: {data}")

    @staticmethod
    async def _get_lead_data(phone: str) -> Dict:
        """Busca dados do lead no PostgreSQL com query otimizada"""
        normalized_phone = normalize_phone(phone)
        pool = await get_db_pool()
        
        async with pool.acquire() as conn:
            row = await conn.fetchrow(
                'SELECT phone, name, status, score, source FROM leads WHERE phone = $1', 
                normalized_phone
            )
            
            if row:
                return {
                    "phone": row['phone'],
                    "name": row['name'], 
                    "status": row['status'],
                    "score": row['score'],
                    "source": row['source']
                }
            return {"phone": normalized_phone, "score": 0, "status": "new"}

    @staticmethod
    async def _get_conversation_history(phone: str) -> List[Dict]:
        """Busca hist√≥rico de conversa no PostgreSQL"""
        normalized_phone = normalize_phone(phone)
        pool = await get_db_pool()
        
        async with pool.acquire() as conn:
            rows = await conn.fetch(
                'SELECT message, is_bot FROM conversations WHERE phone = $1 ORDER BY timestamp DESC LIMIT 10',
                normalized_phone
            )
            
            return [{"message": row['message'], "is_bot": bool(row['is_bot'])} for row in rows]

    @staticmethod
    async def _save_conversation(phone: str, message: str, is_bot: bool):
        """Salva mensagem da conversa no PostgreSQL"""
        normalized_phone = normalize_phone(phone)
        pool = await get_db_pool()
        
        async with pool.acquire() as conn:
            # ‚úÖ VERIFICAR SE LEAD EXISTE ANTES DE SALVAR CONVERSA
            lead_exists = await conn.fetchval(
                'SELECT EXISTS(SELECT 1 FROM leads WHERE phone = $1)', 
                normalized_phone
            )
            
            if not lead_exists:
                # Criar lead b√°sico se n√£o existir
                await conn.execute(
                    'INSERT INTO leads (phone, status, score) VALUES ($1, $2, $3) ON CONFLICT (phone) DO NOTHING',
                    normalized_phone, 'new', 0
                )
            
            # Agora salvar conversa
            await conn.execute(
                'INSERT INTO conversations (phone, message, is_bot) VALUES ($1, $2, $3)',
                normalized_phone, message, is_bot
            )
    @staticmethod
    async def _log_automation(trigger_type: str, phone: str, action: str, result: str):
        """Log das automa√ß√µes executadas no PostgreSQL"""
        normalized_phone = normalize_phone(phone)
        pool = await get_db_pool()
        
        async with pool.acquire() as conn:
            await conn.execute(
                'INSERT INTO automation_logs (trigger_type, phone, action_taken, result) VALUES ($1, $2, $3, $4)',
                trigger_type, normalized_phone, action, result
            )

# ============ ANALYTICS POSTGRESQL OTIMIZADO ============
async def get_analytics_data():
    """Coleta dados para analytics com PostgreSQL otimizado"""
    pool = await get_db_pool()
    
    try:
        async with pool.acquire() as conn:
            # Total de leads √∫nicos (query otimizada)
            total_leads = await conn.fetchval("SELECT COUNT(*) FROM leads")
            
            # DEBUG: Verificar leads
            all_leads = await conn.fetch(
                "SELECT phone, name, status, score, created_at FROM leads ORDER BY created_at DESC LIMIT 20"
            )
            print(f"üîç ANALYTICS PostgreSQL - Total de {total_leads} leads:")
            for lead in all_leads[:5]:  # Mostra apenas os 5 primeiros
                print(f"   üì± {lead['phone']} | Status: {lead['status']} | Score: {lead['score']}")
            
            # Leads por status (query agregada otimizada)
            status_rows = await conn.fetch("""
                SELECT status, COUNT(*) as count
                FROM leads 
                WHERE status IS NOT NULL 
                GROUP BY status
                ORDER BY count DESC
            """)
            leads_by_status = [{"status": row['status'], "count": row['count']} for row in status_rows]
            
            # M√©tricas em uma √∫nica query otimizada
            metrics = await conn.fetchrow("""
                SELECT 
                    COUNT(CASE WHEN score >= 75 THEN 1 END) as leads_qualificados,
                    COUNT(CASE WHEN status = 'qualified' THEN 1 END) as leads_contatados,
                    COUNT(CASE WHEN score >= 85 THEN 1 END) as leads_convertidos,
                    ROUND(AVG(score)::numeric, 1) as avg_score
                FROM leads 
                WHERE score IS NOT NULL
            """)
            
            leads_qualificados = metrics['leads_qualificados']
            leads_contatados = metrics['leads_contatados']
            leads_convertidos = metrics['leads_convertidos']
            avg_score = float(metrics['avg_score']) if metrics['avg_score'] else 0
            
            # Calcular taxas CORRIGIDAS
            taxa_qualificacao = (leads_qualificados / total_leads * 100) if total_leads > 0 else 0
            taxa_contato = (leads_contatados / total_leads * 100) if total_leads > 0 else 0
            taxa_conversao_real = (leads_convertidos / total_leads * 100) if total_leads > 0 else 0
            
            # Receita estimada (ticket m√©dio R$ 800)
            ticket_medio = 800
            receita_gerada = leads_convertidos * ticket_medio
            
            # Hot leads (query otimizada com √≠ndice)
            hot_leads = await conn.fetch("""
                SELECT phone, name, score, updated_at 
                FROM leads 
                WHERE score >= 75 
                ORDER BY score DESC, updated_at DESC
                LIMIT 20
            """)
            hot_leads_list = []
            for lead in hot_leads:
                hot_leads_list.append({
                    "phone": lead['phone'],
                    "name": lead['name'] if lead['name'] else "Lead sem nome",
                    "score": lead['score'],
                    "last_update": lead['updated_at'].isoformat() if lead['updated_at'] else "N/A"
                })
            
            # Distribui√ß√£o de score (query otimizada)
            score_dist = await conn.fetch("""
                SELECT 
                    CASE 
                        WHEN score <= 19 THEN 'Muito Frio (0-19)'
                        WHEN score <= 49 THEN 'Frio (20-49)'
                        WHEN score <= 74 THEN 'Morno (50-74)'
                        ELSE 'Quente (75+)'
                    END as categoria,
                    COUNT(*) as count
                FROM leads 
                WHERE score IS NOT NULL
                GROUP BY 
                    CASE 
                        WHEN score <= 19 THEN 'Muito Frio (0-19)'
                        WHEN score <= 49 THEN 'Frio (20-49)'
                        WHEN score <= 74 THEN 'Morno (50-74)'
                        ELSE 'Quente (75+)'
                    END
                ORDER BY MIN(score)
            """)
            score_distribution = [{"categoria": row['categoria'], "count": row['count']} for row in score_dist]
            
            print(f"üìä M√âTRICAS PostgreSQL CORRIGIDAS:")
            print(f"   Total Leads √öNICOS: {total_leads}")
            print(f"   Qualificados (>=75): {leads_qualificados} ({taxa_qualificacao:.1f}%)")
            print(f"   Contatados: {leads_contatados} ({taxa_contato:.1f}%)")
            print(f"   Convertidos (>=85): {leads_convertidos} ({taxa_conversao_real:.1f}%)")
            print(f"   Score M√©dio: {avg_score}")
            print(f"   Receita: R$ {receita_gerada}")
            
            return {
                "total_leads": total_leads,
                "taxa_qualificacao": round(taxa_qualificacao, 1),
                "leads_qualificados": leads_qualificados,
                "taxa_contato": round(taxa_contato, 1),
                "leads_contatados": leads_contatados,
                "taxa_conversao_real": round(taxa_conversao_real, 1),
                "leads_convertidos": leads_convertidos,
                "receita_gerada": receita_gerada,
                "ticket_medio": ticket_medio,
                "avg_score": avg_score,
                "leads_by_status": leads_by_status,
                "hot_leads_list": hot_leads_list,
                "score_distribution": score_distribution
            }
            
    except Exception as e:
        print(f"‚ùå Erro no get_analytics_data PostgreSQL: {e}")
        return {
            "total_leads": 0,
            "taxa_qualificacao": 0,
            "leads_qualificados": 0,
            "taxa_contato": 0,
            "leads_contatados": 0,
            "taxa_conversao_real": 0,
            "leads_convertidos": 0,
            "receita_gerada": 0,
            "ticket_medio": 0,
            "avg_score": 0,
            "leads_by_status": [],
            "hot_leads_list": [],
            "score_distribution": []
        }

# ============ ROTAS POSTGRESQL ============
@app.post("/leads/{lead_id}/delete")
async def delete_lead(lead_id: int):
    """Exclui um lead espec√≠fico pelo ID (PostgreSQL)"""
    pool = await get_db_pool()
    
    try:
        async with pool.acquire() as conn:
            # PostgreSQL com CASCADE DELETE autom√°tico
            result = await conn.execute("DELETE FROM leads WHERE id = $1", lead_id)
            
            if result == "DELETE 1":
                print(f"üóëÔ∏è Lead {lead_id} removido com sucesso (PostgreSQL)")
            else:
                print(f"‚ö†Ô∏è Lead {lead_id} n√£o encontrado")
    
    except Exception as e:
        print(f"‚ùå Erro ao deletar lead PostgreSQL: {e}")
        raise HTTPException(status_code=500, detail="Erro interno do servidor")
        
    return RedirectResponse(url="/leads", status_code=303)

@app.get("/", response_class=HTMLResponse)
async def dashboard(request: Request):
    """Dashboard principal com m√©tricas PostgreSQL"""
    
    # Buscar dados analytics PostgreSQL
    analytics = await get_analytics_data()
    
    return templates.TemplateResponse("dashboard.html", {
        "request": request,
        **analytics
    })

@app.get("/leads", response_class=HTMLResponse)
async def leads_page(request: Request, status: str = None, search: str = None):
    """P√°gina de gest√£o de leads (PostgreSQL otimizado)"""
    
    pool = await get_db_pool()
    
    async with pool.acquire() as conn:
        # Query base otimizada com √≠ndices
        query = """
            SELECT phone, name, status, score, source,
                   created_at, updated_at
            FROM leads 
            WHERE 1=1
        """
        params = []
        
        # Filtros otimizados
        if status:
            query += f" AND status = ${len(params) + 1}"
            params.append(status)
        
        if search:
            query += f" AND (name ILIKE ${len(params) + 1} OR phone ILIKE ${len(params) + 2})"
            params.extend([f"%{search}%", f"%{search}%"])
        
        query += " ORDER BY updated_at DESC LIMIT 50"
        
        # Executar query otimizada
        leads_rows = await conn.fetch(query, *params)
        leads = [dict(row) for row in leads_rows]
        
        # Status √∫nicos para filtro
        statuses_rows = await conn.fetch("SELECT DISTINCT status FROM leads ORDER BY status")
        statuses = [row['status'] for row in statuses_rows]
    
    return templates.TemplateResponse("leads.html", {
        "request": request,
        "leads": leads,
        "statuses": statuses,
        "current_status": status,
        "current_search": search or ""
    })

@app.get("/lead/{phone}", response_class=HTMLResponse)
async def lead_detail(request: Request, phone: str):
    """Detalhes de um lead espec√≠fico (PostgreSQL)"""
    
    normalized_phone = normalize_phone(phone)
    pool = await get_db_pool()
    
    async with pool.acquire() as conn:
        # Dados do lead
        lead_row = await conn.fetchrow("SELECT * FROM leads WHERE phone = $1", normalized_phone)
        
        if not lead_row:
            raise HTTPException(status_code=404, detail="Lead n√£o encontrado")
        
        lead = dict(lead_row)
        
        # Hist√≥rico de conversas (otimizado)
        conversations_rows = await conn.fetch("""
            SELECT message, is_bot, timestamp
            FROM conversations 
            WHERE phone = $1 
            ORDER BY timestamp ASC
        """, normalized_phone)
        conversations = [dict(row) for row in conversations_rows]
        
        # Logs de automa√ß√£o (otimizado)
        automation_logs_rows = await conn.fetch("""
            SELECT trigger_type, action_taken, result, timestamp
            FROM automation_logs 
            WHERE phone = $1 
            ORDER BY timestamp DESC
            LIMIT 50
        """, normalized_phone)
        automation_logs = [dict(row) for row in automation_logs_rows]
    
    return templates.TemplateResponse("lead_detail.html", {
        "request": request,
        "lead": lead,
        "conversations": conversations,
        "automation_logs": automation_logs
    })

@app.post("/send-message")
async def send_message_form(request: Request, phone: str = Form(...), message: str = Form(...)):
    """Enviar mensagem via formul√°rio (PostgreSQL)"""
    
    # Normalizar telefone
    normalized_phone = normalize_phone(phone)
    
    # Simular envio de mensagem
    trigger = AutomationTrigger(
        trigger_type="message_received",
        data={"phone": normalized_phone, "message": message}
    )
    
    await AutomationEngine.process_automation(trigger)
    
    return {"status": "success", "message": "Mensagem processada via PostgreSQL"}

# ============ LIFESPAN E CONFIGURA√á√ÉO ============
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan events - gerencia ciclo de vida PostgreSQL"""
    # Startup
    try:
        await init_db()
        
        print("üöÄ Previdas PostgreSQL Engine INICIADO!")
        print("‚úÖ Funcionalidades Empresariais:")
        print("   - PostgreSQL com pool de conex√µes (5-20)")
        print("   - Suporte a 1000+ usu√°rios simult√¢neos")
        print("   - Backup autom√°tico e replica√ß√£o")
        print("   - Performance otimizada para produ√ß√£o")
        print("   - √çndices otimizados para consultas r√°pidas")
        print("   - Contexto hist√≥rico mantido")
        print("   - Sistema pronto para escala empresarial")
        print("   - Triggers autom√°ticos para updated_at")
        print("   - Constraints de integridade de dados")
        print("   - BUG de contexto hist√≥rico CORRIGIDO")
        
    except Exception as e:
        print(f"‚ùå Erro na inicializa√ß√£o PostgreSQL: {e}")
        raise
    
    yield
    
    # Shutdown
    try:
        await close_db_pool()
        print("‚úÖ Conex√µes PostgreSQL fechadas com seguran√ßa")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao fechar pool PostgreSQL: {e}")

# Configurar lifespan
app.router.lifespan_context = lifespan

# ============ API ENDPOINTS POSTGRESQL ============
@app.get("/api/")
async def root():
    return {
        "message": "Previdas PostgreSQL Engine - Sistema empresarial otimizado!",
        "version": "2.0.0",
        "database": "postgresql",
        "features": [
            "Pool de conex√µes otimizado",
            "Suporte a 1000+ usu√°rios",
            "Contexto hist√≥rico mantido",
            "Performance empresarial"
        ]
    }

@app.post("/webhook/whatsapp")
async def whatsapp_webhook(data: Dict, background_tasks: BackgroundTasks):
    """Webhook otimizado para PostgreSQL com tratamento de erros"""
    
    try:
        # Extrai e normaliza dados
        phone = normalize_phone(data.get("from", ""))
        message = data.get("text", {}).get("body", "")
        
        if not phone or not message:
            raise HTTPException(status_code=400, detail="Dados inv√°lidos")
        
        # Processa automa√ß√£o em background
        trigger = AutomationTrigger(
            trigger_type="message_received",
            data={"phone": phone, "message": message}
        )
        
        background_tasks.add_task(AutomationEngine.process_automation, trigger)
        
        return {
            "status": "success", 
            "message": "Mensagem processada via PostgreSQL",
            "phone": phone,
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        print(f"‚ùå Erro webhook PostgreSQL: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")

@app.post("/api/leads")
async def create_lead(lead: Lead, background_tasks: BackgroundTasks):
    """Cria novo lead no PostgreSQL"""
    
    # Normalizar telefone
    lead.phone = normalize_phone(lead.phone)
    
    trigger = AutomationTrigger(
        trigger_type="new_lead",
        data=lead.dict()
    )
    
    background_tasks.add_task(AutomationEngine.process_automation, trigger)
    
    return {
        "status": "success", 
        "message": "Lead criado no PostgreSQL", 
        "phone": lead.phone
    }

@app.get("/api/leads/{phone}")
async def get_lead(phone: str):
    """Busca dados de um lead espec√≠fico (PostgreSQL)"""
    normalized_phone = normalize_phone(phone)
    lead_data = await AutomationEngine._get_lead_data(normalized_phone)
    
    if not lead_data or lead_data.get("status") == "new":
        raise HTTPException(status_code=404, detail="Lead n√£o encontrado")
    
    return lead_data

@app.get("/api/analytics/dashboard")
async def get_dashboard_data():
    """Dados corrigidos para dashboard analytics (PostgreSQL)"""
    return await get_analytics_data()

@app.get("/api/conversations/{phone}")
async def get_conversation(phone: str):
    """Busca hist√≥rico de conversa (PostgreSQL)"""
    normalized_phone = normalize_phone(phone)
    history = await AutomationEngine._get_conversation_history(normalized_phone)
    return {"phone": normalized_phone, "conversation": history}

@app.post("/api/trigger-automation")
async def manual_trigger(trigger: AutomationTrigger, background_tasks: BackgroundTasks):
    """Trigger manual de automa√ß√£o (PostgreSQL)"""
    
    # Normalizar telefone se presente
    if "phone" in trigger.data:
        trigger.data["phone"] = normalize_phone(trigger.data["phone"])
    
    background_tasks.add_task(AutomationEngine.process_automation, trigger)
    
    return {"status": "success", "message": "Automa√ß√£o PostgreSQL disparada"}

@app.get("/api/health")
async def health_check():
    """Health check do PostgreSQL"""
    try:
        pool = await get_db_pool()
        async with pool.acquire() as conn:
            result = await conn.fetchval("SELECT 1")
            pool_status = f"{pool._queue.qsize()}/{pool._maxsize}"
            
        return {
            "status": "healthy",
            "database": "postgresql",
            "connection": "ok",
            "pool_status": pool_status,
            "test_query": result,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "database": "postgresql",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

@app.get("/api/stats")
async def get_stats():
    """Estat√≠sticas do sistema PostgreSQL"""
    try:
        pool = await get_db_pool()
        async with pool.acquire() as conn:
            stats = await conn.fetchrow("""
                SELECT 
                    (SELECT COUNT(*) FROM leads) as total_leads,
                    (SELECT COUNT(*) FROM conversations) as total_messages,
                    (SELECT COUNT(*) FROM automation_logs) as total_automations,
                    (SELECT COUNT(*) FROM leads WHERE created_at > NOW() - INTERVAL '24 hours') as leads_today,
                    (SELECT COUNT(*) FROM conversations WHERE timestamp > NOW() - INTERVAL '1 hour') as messages_last_hour
            """)
            
        return {
            "database": "postgresql",
            "total_leads": stats['total_leads'],
            "total_messages": stats['total_messages'],
            "total_automations": stats['total_automations'],
            "leads_today": stats['leads_today'],
            "messages_last_hour": stats['messages_last_hour'],
            "pool_status": f"Connected ({pool._queue.qsize()}/{pool._maxsize})"
        }
    except Exception as e:
        return {"error": str(e)}

# ==================== ENDPOINT DE TESTE CONTEXTO ====================
@app.post("/api/test-context")
async def test_context():
    """Endpoint para testar a corre√ß√£o de contexto hist√≥rico (PostgreSQL)"""
    
    test_scenario = {
        "phone": "619255082",
        "previous_status": "qualified",
        "previous_score": 85,
        "current_message": "quero um seguro como faco"
    }
    
    normalized_phone = normalize_phone(test_scenario["phone"])
    lead_data = await AutomationEngine._get_lead_data(normalized_phone)
    analysis = await AIService.analyze_message(test_scenario["current_message"])
    
    would_maintain_qualification = (
        lead_data.get("status") == "qualified" and 
        analysis["score"] >= 20
    )
    
    return {
        "status": "success",
        "database": "postgresql",
        "test_scenario": test_scenario,
        "current_lead_data": lead_data,
        "ai_analysis": analysis,
        "would_maintain_qualification": would_maintain_qualification,
        "expected_response": "Resposta contextual sobre laudos m√©dicos",
        "fix_applied": "‚úÖ Contexto hist√≥rico CORRIGIDO - PostgreSQL"
    }

# ==================== EXECUTAR ====================
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=8000,
        log_level="info",
        access_log=True
    )